<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Markup | HTML5 Hacks]]></title>
  <link href="http://html5hacks.com/blog/categories/markup/atom.xml" rel="self"/>
  <link href="http://html5hacks.com/"/>
  <updated>2012-11-18T10:13:31-08:00</updated>
  <id>http://html5hacks.com/</id>
  <author>
    <name><![CDATA[Jesse Cravens and Jeff Burtoft]]></name>
    <email><![CDATA[jesse.cravens@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Make Your Page Consumable by Robots and Humans Alike with Microdata]]></title>
    <link href="http://html5hacks.com/blog/2012/11/15/make-your-page-consumable-by-robots-and-humans-alike-with-microdata/"/>
    <updated>2012-11-15T22:34:00-08:00</updated>
    <id>http://html5hacks.com/blog/2012/11/15/make-your-page-consumable-by-robots-and-humans-alike-with-microdata</id>
    <content type="html"><![CDATA[<p>HTML5 microdata provides the mechanism for easily allowing machines to consume the data on your pages, while not affecting the experience for the user.</p>

<p>If you’re like me, you believe that in the future, machines will rule over us humans with an iron fist (provided, of course, that the Zombie Apocalypse doesn’t get us first). While there isn’t anything we can do to help the zombie masses understand the Internet, HTML5 does offer a feature that prepares us for that machine dictatorship. It’s called microdata, and it’s supposed to be for machines only—no humans allowed.</p>

<p>You can tell by now that HTML5 adds a lot of depth to your data, but up to this point the focus has been on your users. Microdata takes you down a slightly different path when you think about consumers who aren’t your users. Microdata is additional context you add to your markup to make it more consumable. When you build your page, you can add these additional attributes to give further context to your markup.</p>

<p>Microdata can be added to any page element to identify that element as an “item” or a high-level chunk of data. The content nested inside that item can then be labeled as properties. These properties essentially become name–value pairs when the itemprop becomes the value name and the human-readable content becomes the value. The relevant code would look something like this:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module
Now imagine how consumable the Web would be for those machines of the future once microdata is utilized on every page!</p>

<p>In this hack we’ll use microdata to make sure our contact list is machine-readable. Each contact entry will be identified as an item, and its contents will be labeled as a property. Our first contact will look like this:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>As you can see, we have constructed one data item on our page, and when the markup is machine-read it will see the item as something like this:
Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>Now let’s build ourselves a whole list:
Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>To our human friends the page looks something like Figure 1-14.</p>

<p><img class="figure" alt="Figure 1-14" src="http://html5hacks.com/images/chapter1-images/microdata1.jpg"></p>

<p>Figure 1-14. Adding microdata to the page, which does not change the view for users</p>

<p>To our machine friends, the code looks something like this:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>It’s that easy to add microdata to your page without sacrificing the interface for your human friends.</p>

<h2>Details, Details!</h2>

<p>Microdata is pretty darn easy to implement, and the W3C spec thinks it should be just as easy to read, which is why the W3C added a JavaScript API to be able to access the data. Remember each of your identified elements was marked with an attribute called itemscope, which means the API considers them items. To get all these items, you simply call the following:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>Now your items can also be segmented by type, so you can identify some of your items as people, and others as cats. Microdata allows you to define your items by adding the itemtype attribute, which will point to a URL, or have an inline definition. In this case, if we defined our cat type by referring to the URL http://example.com/feline, our cat markup would look something like this:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>And if we wanted to get items with only a specific type of cat, we would call:</p>

<p>Liquid error: undefined method `Py_IsInitialized' for RubyPython::Python:Module</p>

<p>Thanks to this simple API, your microdata-enriched markup is both easy to produce and easy to consume.</p>
]]></content>
  </entry>
  
</feed>
